import json
import base64
import audioop
import asyncio
from channels.generic.websocket import AsyncWebsocketConsumer
from home.services.azure_stt import AzureSpeechStream
from home.services.gemini_llm import VoiceAI
from home.services.azure_tts import AzureTTS  # Import the TTS class
import threading

class TwilioMediaConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        await self.accept()
        print("üîó Twilio WebSocket connected")

        self.call_sid = None
        self.stream_sid = None
        self.is_speaking = False
        self.audio_queue = asyncio.Queue()

        # Store async loop for callbacks
        self.loop = asyncio.get_event_loop()
        
        # Initialize Gemini LLM
        self.llm = VoiceAI()
        print("‚úÖ Gemini LLM initialized")

        # Initialize Azure TTS
        self.tts = AzureTTS(voice_name="en-US-JennyNeural")
        print("‚úÖ Azure TTS initialized")

        # Initialize Azure STT with sync callback
        self.azure_stt = AzureSpeechStream(on_final_text=self.sync_final_text_callback)
        print("‚úÖ Azure STT initialized")

        # Start audio sender task
        self.audio_sender_task = asyncio.create_task(self.send_audio_to_twilio())

    def sync_final_text_callback(self, text: str):
        """Sync callback for Azure STT (will schedule async processing)"""
        # Schedule async processing in the event loop
        asyncio.run_coroutine_threadsafe(
            self.async_handle_final_text(text), 
            self.loop
        )

    async def async_handle_final_text(self, text: str):
        """Async handler for final text"""
        print(f"üìù USER SAID (callback): {text}")
        
        try:
            # Stop STT while we're speaking
            self.is_speaking = True
            
            # Generate response from Gemini LLM
            print(f"ü§ñ Generating AI response...")
            reply = self.llm.generate(text)
            print(f"ü§ñ AI REPLY: {reply}")
            
            # Convert text to speech
            await self.speak_response(reply)
            
        except Exception as e:
            print(f"‚ùå Error generating AI response: {e}")
            fallback = "I understand. How can I help you?"
            print(f"ü§ñ FALLBACK REPLY: {fallback}")
            await self.speak_response(fallback)
        finally:
            # Resume STT
            self.is_speaking = False

    async def speak_response(self, text: str):
        """Convert text to speech and send to Twilio"""
        print(f"üó£Ô∏è  Converting to speech: {text}")
        
        def tts_complete_callback(audio_bytes: bytes):
            """Callback when TTS audio is ready"""
            # Schedule async processing
            asyncio.run_coroutine_threadsafe(
                self.handle_tts_audio(audio_bytes),
                self.loop
            )
        
        # Generate TTS asynchronously
        self.tts.speak_async(text, tts_complete_callback)

    async def handle_tts_audio(self, audio_bytes: bytes):
        """Handle TTS audio bytes and prepare for sending"""
        if not audio_bytes:
            print("‚ö†Ô∏è  No audio generated by TTS")
            return
        
        print(f"üîä TTS generated {len(audio_bytes)} bytes")
        
        # Process audio: 16kHz PCM ‚Üí 8kHz Œº-law for Twilio
        try:
            # Convert 16kHz PCM to 8kHz PCM
            pcm_8k, _ = audioop.ratecv(
                audio_bytes, 
                2,      # 2 bytes per sample (16-bit)
                1,      # 1 channel (mono)
                16000,  # Input sample rate
                8000,   # Output sample rate
                None
            )
            
            # Convert PCM to Œº-law
            mulaw_bytes = audioop.lin2ulaw(pcm_8k, 2)
            
            # Split into chunks (160 bytes = 20ms at 8kHz)
            chunk_size = 160  # 20ms chunks for 8kHz
            for i in range(0, len(mulaw_bytes), chunk_size):
                chunk = mulaw_bytes[i:i + chunk_size]
                if chunk:
                    # Put in queue for sending
                    await self.audio_queue.put(chunk)
                    
        except Exception as e:
            print(f"‚ùå Error processing TTS audio: {e}")

    async def send_audio_to_twilio(self):
        """Continuously send audio from queue to Twilio"""
        while True:
            try:
                mulaw_chunk = await self.audio_queue.get()
                
                # Encode chunk to base64
                payload = base64.b64encode(mulaw_chunk).decode('utf-8')
                
                # Create media message
                media_message = {
                    "event": "media",
                    "streamSid": self.stream_sid,
                    "media": {
                        "payload": payload
                    }
                }
                
                # Send to Twilio
                await self.send(text_data=json.dumps(media_message))
                
                # Send mark message every few chunks
                if self.audio_queue.qsize() % 10 == 0:
                    mark_message = {
                        "event": "mark",
                        "streamSid": self.stream_sid,
                        "mark": {
                            "name": f"chunk_{self.audio_queue.qsize()}"
                        }
                    }
                    await self.send(text_data=json.dumps(mark_message))
                    
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"‚ùå Error sending audio: {e}")
                await asyncio.sleep(0.1)

    async def receive(self, text_data=None, bytes_data=None):
        if not text_data:
            return

        try:
            message = json.loads(text_data)
            event = message.get("event")

            if event == "start":
                self.call_sid = message["start"]["callSid"]
                self.stream_sid = message["start"]["streamSid"]
                print(f"üìû Call started | {self.call_sid}")
                
                # Send initial greeting
                await self.async_handle_final_text("hello")

            elif event == "media":
                # Skip processing if we're speaking
                if self.is_speaking:
                    return
                    
                payload = message["media"]["payload"]

                # Decode base64
                mulaw_bytes = base64.b64decode(payload)

                # Œº-law ‚Üí 16-bit PCM @ 8kHz
                pcm_8k = audioop.ulaw2lin(mulaw_bytes, 2)

                # Resample 8k ‚Üí 16k for Azure STT
                pcm_16k, _ = audioop.ratecv(pcm_8k, 2, 1, 8000, 16000, None)

                # Push audio to Azure STT
                self.azure_stt.push_audio(pcm_16k)

            elif event == "stop":
                print(f"üõë Call ended | {self.call_sid}")
                await self.cleanup()
                
        except Exception as e:
            print(f"‚ùå Error processing message: {e}")

    async def cleanup(self):
        """Clean up resources"""
        # Cancel audio sender task
        if hasattr(self, 'audio_sender_task'):
            self.audio_sender_task.cancel()
            try:
                await self.audio_sender_task
            except asyncio.CancelledError:
                pass
        
        # Close STT
        if hasattr(self, 'azure_stt'):
            self.azure_stt.close()
        
        # Close TTS
        if hasattr(self, 'tts'):
            self.tts.close()
        
        # Close WebSocket
        await self.close()

    async def disconnect(self, close_code):
        print(f"‚ùå WebSocket disconnected | code={close_code}")
        await self.cleanup()